<!docktype html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="/img/favicon.svg" type="image/svg+xml" sizes="any">
	<link rel="shortcut icon" type="image/png" href="/img/favicon.png">
	<link rel="shortcut icon" sizes="192x192" href="/img/favicon.png">
	<link rel="apple-touch-icon" href="/img/favicon.png">
	<title>Sort of School</title>
	<link href="../style.css" rel="stylesheet" />
	<script>
	MathJax = {
		loader: {
				load: ['input/tex-base', 'output/svg']
			},
        tex: {
            tags: 'none', // should be 'ams', 'none', or 'all'
            tagSide: 'right',
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
            enableMenu: false
        }
    };
	</script>

	<style>
		table {
		  width: 100%;
		  border-collapse: collapse;
		}

		th,
		td {
		  text-align: left;
		  border-bottom: 1px solid #ddd;
		}

		td:nth-child(odd){
			background-color: #f2f2f2;
		}

		tr:hover {
		  background-color: #ddd;
		}
	</style>


	<script id="MathJax-script" async
	  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
	</script>
</head>

<body>
	<a id="top"></a>
	<header>
		<script src="../header.js"></script>
	</header>

	<div class="image"><img class="image" src="qr_codes/revelation.png">
		<div>&nbsp</div>
		<div>King James Bible (1611)</div>
	</div>

	<div class="content-container">

	<div id="toc">
	    <h2>Table of Contents</h2>
	    <ol>
	    	<li><a href="#top"><b>QR codes</b></a></li>
	        <li><a href="#QR_first_version">QR First Version</a></li>
	        <li><a href="#Finder_patterns">Finder Patterns</a></li>
	        <li><a href="#Timing_Patterns">Timing Patterns</a></li>
	        <li><a href="#Additional_Information">Additional Information</a></li>
	        <li><a href="#Modes_of_Encoding">Modes of Encoding</a></li>
	        <li><a href="#Message_Length">Message Length</a></li>
	        <li><a href="#Byte_Mode_Encoding">Byte Mode Encoding</a></li>
	        <li><a href="#Numeric_Mode">Numeric Mode</a></li>
	        <li><a href="#Alphanumeric_Mode">Alphanumeric Mode</a></li>
	        <li><a href="#Kanji_Mode">Kanji Mode</a></li>
	        <li><a href="#Error_Correction_Level">Error Correction</a></li>
			<li><a href="#Mask_Problem">Mask Problem</a></li>
			<li><a href="#EC_and_Mask_for_Additional_Information">EC and Mask for Additional Information</a></li>
	        <li><a href="#Additional_links"><b>Additional Links</b></a></li>
	    </ol>
	</div>


		<div class="page">
			<h1>QR codes</h1>

			<!-- <h2>Youtube video</h2> -->
			<iframe src="https://www.youtube.com/embed/SZEHDjV07J0" title="YouTube video player" frameborder="0" controls="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

			<section id="QR_first_version">
			<h2>QR first version</h2> 
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/1_QR_first_version.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>QR first version & MicroQR</div>
			</div>

			<p>The ISO 18004 Standard is like a guidebook for QR codes. It's 126 pages long and tells us how QR codes are made. 
			</p>

			<p>I am creating the First Version of the QR code, it’s the simplest one, and its matrix consists of 21 by 21 modules. The other versions are bigger, so it’s harder to show them on a small screen. 
			</p>

			<p>
			There is also a Micro-QR version, which is really cool, but almost none of the QR-code scanner apps could read them.
			</p>
			</section>

			<section id="Finder_patterns">
			<h2>Finder patterns</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/2_Finder_patterns.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Finder patterns help to orient the QR code</div>
			</div>

			<p>
			Now, the square doesn’t have any properties that would help distinguish the top from the bottom and determine that it is a QR code that we see and not a grid paper. So let there be <b>finder patterns</b> in three corners. That way we can always orient the QR-code the right way, no matter what angle it was shot from. The finder patterns always occupy 8 by 8 modules in these corners.
			</p>
			</section>

			<section id="Timing_Patterns">
			<h2>Timing Patterns</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/3_Timing_patterns.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Position of Timing Patterns</div>
			</div>

			<p>The next problem is that there are no grids on real QR codes. Without them, it's hard to tell where each module is. Therefore, to help the scanner distinguish the columns and the rows from each other, we need so-called <b>timing patterns</b>. These consist of lines of alternating dark and light modules that connect the finder patterns, plus one dark module situated close to the bottom-left finder pattern and they help to distinguish between rows and columns.</p>
			</section>

			<section id="Additional_Information">
			<h2>Additional Information</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/4_Additional_info.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Additional Information</div>
			</div>

			<p>Finally, strips of modules with a thickness of one are reserved by now for <b>additional information.</b></p>
			</section>

			<section id="Modes_of_Encoding">
			<h2>Modes of Encoding</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/5_Modes_of_encoding.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Modes of Encoding modules</div>
			</div>

			<p>All these elements, from search patterns, to timing patterns can be found in any QR code. A message is written into the rest of the modules by painting some of them black. But why use black cells instead of letters?</p>

			<p>There are actually 4 main alphabets or modes of encoding that can be used:</p>

			<ul class = "enum">
			    <li>Numeric</li>
			    <li>Alphanumeric</li>
			    <li>Byte</li>
			    <li>Kanji</li>
			</ul>

			<p>So before writing our message, we need to specify the method of encoding that we use. For this, the first four modules in the bottom right corner of the QR code are assigned. By choosing one of the modes, we are painting the corresponding module black. </p>

			<p>Let's start with the <b>byte mod</b> to understand the basics. This alphabet contains 256 different symbols from a specified character set (ISO/IEC 8859-1). Small and capital letters, numbers, punctuation marks and anything else you might need to write a message. 
			</p>

			<table border="1">
			  <tbody id="characterTableBody"></tbody>
			</table>

			<!-- ISO/IEC 8859-1 table script -->
			<script>
			document.addEventListener("DOMContentLoaded", function() {
			    const tableBody = document.getElementById('characterTableBody');

			    // Control character names
			    const controlChars = [
			        "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
			        "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI",
			        "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
			        "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"
			    ];

			    // For 32 rows
			    for(let row = 0; row < 32; row++) {
			        const tableRow = document.createElement('tr');

			        // For 8 character slots per row
			        for(let col = 0; col < 8; col++) {
			            const decimalValue = col * 32 + row;

			            // Add decimal cell
			            const decimalCell = document.createElement('td');
			            decimalCell.textContent = decimalValue;
			            tableRow.appendChild(decimalCell);

			            // Add character or control character name
			            const charCell = document.createElement('td');
			            if (decimalValue < 32) {
			                charCell.textContent = controlChars[decimalValue];
			            } else if (decimalValue <= 255) {
			                charCell.textContent = String.fromCharCode(decimalValue);
			            }
			            tableRow.appendChild(charCell);
			        }

			        tableBody.appendChild(tableRow);
			    }
			});
			</script>
			</section>

			<section id="Message_Length">
			<h2>Message Length</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/6_Message_length.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Message Length modules</div>
			</div>

			<p>Let’s see how we can represent some information using it. For example the 10-letter string <b><code>HELLOWORLD</code></b>. The next 8 modules in QR-code are allocated to represent the length of our message. Each module is assigned a number equal to a power of two in a specific order. The next step is to paint the corresponding modules, so their sum is equal to the length of the message, in our case it is 8 and a 2.</p>
			</section>

			<section id="Possible_Combinations">
			<h2>Possible Combinations</h2>
			<div class="video">
				<video width="100%" controls>
					<source src="qr_codes/7_Possible_combinations.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> 
				<div>&nbsp;</div>
				<div>Combinations of 1, 2, 3 and 4 modules</div>
			</div>

			<p>Now we are ready to encode characters themself. How can we use modules to do that?</p>
			<ul>
				<li>1 module: 2 combinations (black or white) which can represent numbers 0 and 1 or letters A and B.</li>
				<li>2 modules: We get 4 combinations, representing numbers 0 to 3 or letters A to D.</li>
				<li>3 modules: This gives 8 combinations.</li>
				<li>4 modules: We have 16 combinations, which can represent numbers 0 to 15 or letters A to P.</li>
			</ul>

			<p>Moreover if the number of modules that is used to encode one character equals \(N\), the number of possible characters equals \(2^N\).
			</p>

			<p>
			$$ \text{possible combinations} = 2^N $$
			</p>
			</section>

			<section id="Byte_Mode_Encoding">
			<h2>Byte Mode Encoding</h2>
			<div class="image">
			    <img class="image" src="qr_codes/8_Byte_mode_block.png" alt="Byte mode block">
			    <div>&nbsp</div>
			    <div>Byte Mode Block Representation</div>
			</div>

			<p>To simplify the process of creating a block that corresponds to some number, we assign to each module in a block a number that is equal to a power of two. The sum of the numbers in the modules that are painted black equal to the number that block represents.</p>


			<blockquote class="stylish-quote">
			    <strong>Why Powers of Two?</strong> The choice of powers of two is rooted in binary representation, the fundamental language of computers. In binary, everything is represented using only two numbers: 0 and 1. This system is efficient and universal for digital encoding.
			</blockquote>

			<p>In byte-mode we have 256 possible characters that we can use in our message. So, to be able to represent any character from this sheet we need 8 modules in a block.
			</p>

			<p>For example:</p>
			<ul class = "enum">
				<li>If only the modules representing the numbers 64 and 1 are colored black, this block represents the 65th character, which is 'A'.</li>
				<li>If all the modules in a block are colored black, it represents the last character in the set — some strange French umlaut 'ÿ'.</li>
			</ul>
			</section>

			<section id="Letter_Placement_and_Encoding">
			<h2>Letter Placement and Encoding</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/9_Letters_placement.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp</div>
			    <div>Letter Placement Process</div>
			</div>

			<p>That's why for every character in our message we are allocating a block of 8 modules in this specific order. Then, we change each character to its according number on the character sheet. This number then tells us which modules to color black in our 8-module block.</p>
			</section>

			<section id="Zigzag_Order_and_Module_Assignment">
			<h2>Zigzag Order and Module Assignment</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/10_Zigzag_order.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp</div>
			    <div>Zigzag Order in QR Code</div>
			</div>

			<p>Each module within a block is assigned a value based on powers of two, but this assignment follows a specific zig-zag order. Once these values are assigned, the next step involves painting the modules. The modules are painted such that their combined value matches the number representing a specific character.</p>
			</section>

			<section id="Encoding_Letters_in_QR_Codes">
			<h2>Encoding Letters in QR Codes</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/11_Encoding_letters.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp</div>
			    <div>Encoding the Letter 'H'</div>
			</div>

			<p>Let's take the letter 'H' as an example:</p>

			<p>The letter 'H' might be the seventy-second character in the list. To represent the number 72, we break it down into its power of two components: 64 and 8. Thus, in the block representing 'H', the modules corresponding to the values 64 and 8 are painted black.</p>

			<p class="equation">
			\[ (H) 72 = 64 + 8 \]
			</p>

			<p>This method ensures that each character in the message is uniquely represented by a combination of black and white modules in its corresponding block. Once we've encoded our entire message, we need a way to show that the message is complete. This is done using a <b>terminator</b>, which is simply four white modules in a row.</p>
			</section>

			<section id="Why_Not_Always_Use_Byte_Mode?">
			<h2>Why Not Always Use Byte Mode?</h2>
			<div class="image">
			    <img class="image" src="qr_codes/12_Byte_mode_max_length.png">
			    <div>&nbsp</div>
			    <div>Limitations of Byte Mode</div>
			</div>

			<p>You might wonder, with byte mode's ability to represent so many characters, why bother with other modes? While byte mode does offer a wide range of characters, it has a limitation. Using byte mode, we can only encode a message up to 17 characters long. We also can't use all the modules, as some are reserved for error correction later on.</p>

			<p><b>Numeric</b> and <b>Alphanumeric</b> modes offer a more efficient way to encode messages. They use clever encoding methods that let us fit more characters into the same QR code size without making it bigger. This means we can convey longer messages without needing a larger QR code.</p>
			</section>

			<section id="Numeric_Mode">
			<h2>Numeric Mode</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/13_Numeric_mode.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Numeric Mode in Action</div>
			</div>
			<p>Numeric mode is designed specifically for encoding numbers. It's perfect for things like prices, phone numbers, book indexes, or tracking inventory items. In this mode, only the digits 0 through 9 are used.</p>

			<p>If we follow the logic we've learned, encoding 10 different symbols (the numbers 0-9) would require at least 4 modules. Why? Because 3 modules can only represent 8 different combinations \(2^3 = 8\), which isn't enough for 10 numbers.</p>

			<p>\(2^4=16\) which is greater than 10. So, 4 modules can represent all 10 numbers with some combinations to spare.</p>

			<p>When we divide our modules into blocks of four, we can fit 34 digits using Numeric mode.</p>
			</section>

			<section id="Numeric_vs_Byte Mode">
			<h2>Numeric vs. Byte Mode</h2>
			<div class="image">
			    <img class="image" src="qr_codes/14_Numeric_Byte_length_comparation.png">
			    <div>&nbsp;</div>
			    <div>Numeric vs. Byte Mode Capacity</div>
			</div>

			<p>Numeric mode has a greater capacity than if we were using the 256-character alphabet of byte mode. The key takeaway here is simple: 
			
			<p class = "takeaway">
			The fewer characters in our chosen alphabet, the more information we can pack into the same QR code space.
			</p>
			</section>

			<section id="Numeric_Mode_4bit">
			<h2>Numeric Mode 4bit</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/15_Numeric_4bit.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Utilization in Numeric Mode</div>
			</div>

			<p>But this approach is not very effective. By choosing to use only 10 out of all 16 combinations, we actually use only 62.5% of the available space!</p>

			<div class="equation">
			    $$ \frac{2^4}{10} = \frac{10}{16} = 62.5\% $$
			</div>
			</section>

			<section id="Numeric_Mode_10bit">
			<h2>Numeric Mode 10bit</h2>
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/16_Numeric_10bit.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Numeric Mode with 10 Modules</div>
			</div>

			<p>To make better use of the available space, numeric mode actually sets aside 10 modules for encoding, not just 4. This allows for:</p>

			<div class="equation">
			    $$ 2^{10} = 1024 $$
			</div>

			<p>possible characters or combinations.</p>

			<p>Consider encoding a date: </p>

			 <div class="equation">
			    $$18082023$$
			</div>

			<p>
			Before encoding, we can split the date into groups of three digits: </p>

			<div class="equation">
			    $$180/ 820/ 23$$
			</div>

			<p>
			Each group is then encoded as a 10-bit number. Given that there are only 1000 possible numbers ranging from 0 to 999, this method achieves nearly 98% utilization of the available space.</p>

			<div class="equation">
			    $$ \frac{1000}{2^{10}} = \frac{1000}{1024} \approx 98% $$
			</div>

			<p>Think of this encoding method as translating our message into a unique language. In this language, the alphabet consists of 1000 characters. By using this approach, we're making the most out of the space provided by the QR code, ensuring efficient and compact encoding.</p>
			</section>

			<section id="Numeric_Encoding_Efficiency">
			<h2>4-bit vs 10-bit Numeric Encoding Efficiency</h2>
			<div class="image">
			    <img class="image" src="qr_codes/17_4bit_10bit_length_comparation.png">
			    <div>&nbsp;</div>
			    <div>4-bit vs 10-bit Encoding Efficiency</div>
			</div>

			<p>By using the encoding method where we group three digits together and represent each group with 10 modules, we can achieve impressive efficiency. This method allows us to encode a message that's 41 characters long, provided the message is made up entirely of digits.</p>
			</section>

			<section id="Alphanumeric_Mode">
			<h2>Alphanumeric Mode</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/18_Alphanumeric_mode.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Exploring Alphanumeric Mode</div>
			</div>

			<p>The <b>alphanumeric mode</b> allows to encode the above digits, A to Z upper-characters, and some symbols, which makes it the best option for encoding the links to web-sites.</p>
			</section>

			<section id="Alphanumeric_Efficiency_6-bit">
			<h2>Alphanumeric Efficiency with 6-bit Encoding</h2>

			<div class="image">
			    <img class="image" src="qr_codes/19_Alphanumeric_wasteful.png">
			    <div>&nbsp;</div>
			    <div>Alphanumeric 6-bit Efficiency</div>
			</div>

			<p>With 45 symbols in the alphanumeric set, direct encoding (one symbol at a time) would need at least 6 modules. However, this method would only use about 70% of the available space.</p>
			</section>

			<section id="Alphanumeric_Efficiency_11-bit">
			<h2>Alphanumeric Efficiency with 11-bit Encoding</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/20_Alphanumeric_11bit.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Alphanumeric 11-bit Efficiency</div>
			</div>

			<p>To improve efficiency, a similar approach to the one used in numeric mode is employed. Instead of encoding each character individually, the string is divided into pairs of characters. Essentially, every two-symbol combination becomes a new, unique character.</p>

			<p>How many unique pairs can be formed? By pairing each symbol with every other symbol (including itself), we create a 45 by 45 grid of combinations. This results in:</p>
			<div class="equation">$$45^2 = 2025$$</div>

			<p>unique pairs. To represent all 2025 combinations, we'd need combinations from 11 modules, which can represent:</p>
			<div class="equation">$$2^{11} = 2048$$</div>

			<p>combinations. This method achieves an impressive utilization of nearly 99%!</p>
			<div class="equation">$$\frac{2025}{2048} ≈ 98.8\%$$</div>
			</section>

			<section id="Kanji_Mode">
			<h2>Kanji Mode</h2>

			<div class="image">
			    <img class="image" src="qr_codes/21_Kanji.png" alt="Kanji Mode QR Code">
			    <div>&nbsp;</div>
			    <div>The Kanji Encoding</div>
			</div>

			<p>The Kanji mode is designed to encode the vast array of characters in the Kanji alphabet, which consists of 6090 characters. To represent each character, 13 modules are allocated. This results in a utilization of about 75%. Given the size constraints of our QR code, only 10 Kanji characters can fit. No tricks are used here to achieve better utilization.</p>
			</section>

			<section id="Error_Correction_Level">
			<h2>Error Correction Level</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/22_Error_correction_level.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Error Correction in QR Codes</div>
			</div>

			<p>One remarkable feature of QR codes is their robustness. Whether they're partially obscured, damaged, or even if a logo covers part of the code, they remain readable. This resilience is largely due to error correction.</p>

			<p>Let's explore error correction using the byte mode, as it's visually simpler. </p>

			<p>There are four levels of error correction, each requiring a different amount of space in the QR code. The higher the error correction level, the more robust the QR code is against damage, but the less space remains for the actual message. For our QR code size, we can encode:</p>

			<ul class = "enum">
			    <li>7 characters at High level</li>
			    <li>11 characters at Quartile level</li>
			    <li>14 characters at Medium level</li>
			    <li>17 characters at Low level</li>
			</ul>
			</section>

			<section id="Error_Correction_Bits">
			<h2>Error Correction Bits</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/23_Error_correction_bits.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Error Correction Bits in QR Codes</div>
			</div>

			<p>To indicate the chosen error correction level, only 2 modules are needed, as there are just four levels. They are placed in additional information.</p>
			</section>

			<section id="Pad_Blocks">
			<h2>Pad Blocks</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/24_Pad_blocks.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Padding in QR Codes</div>
			</div>

			<p>Let’s get back to our message "HELLOWORLD" and we'll use the Low level of error correction, which allows for a message up to 17 characters long. The remaining space, enough for 7 characters, is reserved for error correction.</p>

			<p>However, our message is only 10 characters long. To utilize the unused space, two alternating characters from the character sheet are used, specifically characters numbered 236 and 17. These characters likely create a contrasting pattern, ensuring they aren't mistaken for actual data.</p>

			<p>The 7 blocks of 8 modules allocated for these padding characters are encoded similarly to our main message. Any timing pattern in the way is skipped. Each module in a block is given a value based on powers of two, and the necessary modules are colored to represent the character.</p>

			<p>With our message encoded, all that remains is to fill in the error correction blocks, ensuring our QR code is both informative and resilient.</p>
			</section>

			<section id="Reed-Solomon_Error_Correction">
			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/25_Reed_Solomon.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Understanding Reed-Solomon Error Correction</div>
			</div>

			<p>The Systematic Reed-Solomon Error correction in Galois Fields is a daunting task. Let’s start with just Reed-Solomon and look at Galois Fields later.</p>

			<p>Due to difficulty of calculations, we’ll take a shorter message, for example <b><code>GOD</code></b>. Using the byte-mode alphabet, the characters G, O, and D are assigned the numbers 71, 79, and 68, respectively. Our goal is to create codewords – error correction numbers that can help restore the original numbers if they get corrupted. The Reed-Solomon error correction is designed such that only half the number of codewords can be recovered. For instance, to recover 1 corrupted symbol, 2 codewords are needed.</p>

			<p>The generator polynomial is created with known roots, equal to the number of codewords. For our example, the roots are 1 and 2, resulting in the polynomial:</p>
			<div class = 'equation'>
			$$ g(x) = x^2 - 3x + 2 $$
			</div>

			<p>This polynomial equals zero when \( x \) is 1 or 2.</p>
			<div class = 'equation'>
			$$
				\begin{cases}
				g(1) = 0 \\
				g(2) = 0
				\end{cases}
			$$
			</div>

			<p>The message polynomial is derived from the original message numbers and is multiplied by \( x \) raised to the power of the number of codewords:</p>

			<div class = 'equation'>
			$$ m(x) = (71x^2 + 79x + 68) x^2 = 71x^4 + 79x^3 + 68x^2 $$
			</div>

			<p>To obtain the codewords, polynomial division is performed between the message polynomial and the generator polynomial. The result is a quotient and a remainder. The difference between the message polynomial and the remainder polynomial equals the quotient multiplied by the generator polynomial. The remainder serves as the codewords.</p>

			<p>For our example, the remainder polynomial is:</p>

			<div class = 'equation'>
			$$ r(x) = 1822x - 1604 $$
			</div>

			<p>And the polynomial to be transmitted:</p>
			<div class = 'equation'>
			$$ s(x) = m(x) - r(x) = 71x^4 + 79x^3 + 68x^2 - 1822x + 1604 $$
			</div>
			</section>

			<section id="Reed-Solomon_Verification_and_Restoration">
			<h2>Reed-Solomon Error Correction: Verification and Restoration</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/26_Reed_Solomon_correction.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Restoring Corrupted QR Code Messages</div>
			</div>

			<p>When we receive a QR code message, we can verify its integrity by substituting values into the polynomial. For instance, using values 1 and 2:</p>

			<div class = 'equation'>
			$$ s(x) = 71x^4 + 79x^3 + 68x^2 - 1822x + 1604 $$
			</div>

			<div class = 'equation'>
			$$
				\begin{cases}
				s(1) = 0 \\
				s(2) = 0
				\end{cases}
			$$
			</div>

			<p>If the result is zero, it indicates that the message has not been corrupted.</p>

			<p>However, let's imagine a scenario where the first coefficient is tampered with, changing it to 77. This would alter the message, potentially changing its meaning:</p>

			<div class = 'equation'>
			$$ [77, 79, 68, -1822, 1604] $$
			</div>

			<p>To detect and correct this error, we can employ a method that involves replacing the suspected incorrect coefficient with a variable, say \( P \):</p>

			<div class = 'equation'>
			$$ s(x) = Px^4 + 79x^3 + 68x^2 - 1822x + 1604 $$
			</div>

			<p>Given that this polynomial should equate to zero when \( x \) is either 1 or 2, we can substitute these values in:</p>

			<div class = 'equation'>
			$$
				\begin{cases}
				s(1) = P + 79 + 68 - 1822 + 1604 = 0 \\
				s(2) = 16P + 632 + 272 - 3644 + 1604 = 0
				\end{cases}
			$$
			</div>

			<p>Solving these equations, we find that in both cases, \( P \) equals 71. </p>

			<div class = 'equation'>
			$$
				\begin{cases}
				P = 71 \\
				P = 71
				\end{cases}
			$$
			</div>



			<p>This confirms that the original coefficient was 71, and the message has been restored. If the results were different, we would continue this process with the next coefficient until the corrupted one is identified.</p>

			<blockquote class="stylish-quote">
				<strong>Additional Links on Reed-Solomon:</strong>
				<ul>
				    <li><a href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html" target="_blank">Reed-Solomon Error Correcting Codes from the Bottom Up by tomverbeure</a></li>
				    <li><a href="https://www.youtube.com/watch?v=1pQJkt7-R4Q" target="_blank">What are Reed-Solomon Codes by vcubingx</a></li>
				</ul>
			</blockquote class="stylish-quote">
			</section>

			<section id="Galois_Fields">
			<h2>Galois Fields in QR Code Error Correction</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/27_Galois_field.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Adapting Reed-Solomon for QR Code Encoding</div>
			</div>

			<p>While the Reed-Solomon error correction method seems promising, applying it directly to QR codes presents challenges. With 8 modules per block, the highest number we can encode is 255. However, our codewords are in the thousands, and some are even negative. This is where <b>Galois fields</b> come into the picture.</p>

			<p>In Galois fields, we don't rely on traditional arithmetic. Instead, we work with numbers up to 255. Addition and subtraction are performed using XOR (exclusive or), while multiplication and division are rooted in logarithmic and exponential tables (there are also other methods that can be used). Despite these unconventional rules, the essence of codeword generation, error detection, and correction remains the same. This method ensures all numbers stay within the 0-255 range, making them encodable in 8-bit blocks.</p>

			<p>Attempting these calculations by hand, even for a short word, is a daunting task. For our <b><code>HELLOWORLD</code></b> message, which has 10 letters and requires 7 codewords, manual calculations are impractical. The challenge lies in our unfamiliarity with this unique arithmetic. For those intrigued, there's an article detailing the arithmetic rules of the Galois field and a 16-step solution for a basic message.

			<blockquote class="stylish-quote">
			    <strong>Error Correction Coding in Galois fields by Thonky</strong> <br>
			    <a href="https://www.thonky.com/qr-code-tutorial/error-correction-coding">https://www.thonky.com/qr-code-tutorial/error-correction-coding</a>
			</blockquote>

			</p>

			<p>If you want to skip this step, you can do it with a program that I've developed for step-by-step QR code generation, available on my website as an open-source tool.</p>

			<blockquote class="stylish-quote">
			    <strong>QR Code step-by-step Generation Tool</strong> <br>
			    <a href="https://sortofschool.org/tools/qr/qr">https://sortofschool.org/tools/qr/qr</a>
			</blockquote>
		</section>

		<section id="Error_Correction_Modules_Placement">
		<h2>Error Correction Modules Placement in QR Code</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/28_EC_module_placement.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Assigning and Placing Error Correction Modules</div>
			</div>

			<p>Using the above methods, we're able to determine the 7 error correction blocks required for encoding the message <b><code>HELLOWORLD</code></b>. Once obtained, a power-of-two number is assigned to each of these blocks. They are then strategically placed in a distinct zig-zag pattern within the QR code.</p>

			<p>The modules are then colored in, ensuring that the sum of the colored modules aligns with the error correction number. With this step complete, we've successfully finished the Error Correction component of the QR code.</p>
			</section>

			<section id="Mask_Problem">
			<h2>Mask Problem</h2>

			<div class="image">
			    <img class="image" src="qr_codes/29_Mask_problem.png" alt="Mask Problem in QR Codes">
			    <div>&nbsp;</div>
			    <div>Reason for Masking in QR Codes</div>
			</div>

			<p>
			While our QR code might seem ready, there's a significant challenge we haven't addressed: the issue of uniformity. Large clusters of white or black modules can make individual cells difficult to distinguish. To illustrate this, consider encoding a message made up of the last 17 characters of the byte-mode alphabet, the strange French umlauts:
			</p>

			<p style="text-align: center;">
			ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
			</p>
			<p>
			Such a message would result in a QR code with large, uniform areas, making it hard to scan.
			</p>

			<p>
			That's where masks come into play. Masks are patterns applied to the data portion of the code to break up large areas of uniform color. This makes the QR code easier to scan and read.
			</p>

			<p>
			When a QR code has extensive areas that are either unpainted or entirely black, it becomes challenging for scanners to differentiate between individual modules. Masks help by introducing variability into the design, ensuring that no large uniform areas exist. This variability aids in the accurate scanning of the QR code.
			</p>
			</section>

			<section id="Types_of_Masks">
			<h2>Types of Masks</h2>

			<div class="image">
			    <img class="image" src="qr_codes/30_Mask_types.png" alt="Types of Masks in QR Codes">
			    <div>&nbsp;</div>
			    <div>Different Types of Masks in QR Codes</div>
			</div>

			<p>
			There are eight standard masks used in QR code generation. Each mask has a unique pattern, and the best one is chosen based on specific criteria, such as which results in the least number of uniform areas. The selected mask is then applied to the QR code, ensuring a more varied and scannable design.
			</p>
			</section>

			<section id="Mask_Application">
			<h2>Mask Application Process</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/31_Mask_application.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Application of Mask on a QR Code</div>
			</div>

			<p>
			The process of masking involves XORing ("exclusive or" operation) the chosen mask with the data and error correction blocks of the QR code. Here's a visual breakdown:
			</p>

			<ol class = "enum">
			    <li>Overlap the QR code with the selected mask.</li>
			    <li>Modules that are bright or dark remain white.</li>
			    <li>Gray modules turn black.</li>
			</ol>

			<p>
			It's essential to note that this operation is exclusive to data and error correction modules. Finder patterns, timing patterns, and additional information remain unchanged by the mask.
			</p>

			<p>
			When it comes to decoding a masked QR code, the process is straightforward. By performing the same XOR operation with the mask, the QR code reverts to its original state, making it readable.
			</p>
			</section>

			<section id="Mask_Evaluation">
			<h2>Mask Evaluation Process</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/32_Mask_evaluation.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Evaluating Suitable Masks for QR Code</div>
			</div>

			<p>
			While you can manually select any of the eight masks using my program, real-world algorithms take a more sophisticated approach. They generate all eight masks simultaneously and then evaluate which one is the most suitable for the given QR code. This evaluation is based on a "beauty contest" of sorts, where each mask is scored based on its effectiveness.
			</p>

			<p>
			The most "attractive" mask is the one with the lowest penalty score. These scores are derived from four main rules:
			</p>

			<ul class = "enum">
			    <li>Sequences: Avoid long vertical or horizontal sequences of modules with the same color.</li>
			    <li>Large Areas: Minimize extensive areas that have the same color.</li>
			    <li>Finder Pattern Resemblance: Evade patterns that look like the finder pattern.</li>
			    <li>Balance: Aim for an overall balance between dark and light modules.</li>
			</ul>

			<p>
			After evaluating each mask based on these rules, the one with the lowest penalty score is chosen and applied to the QR code.
			</p>
			</section>

			<section id="Mask_Bits_Allocation">
			<h2>Mask Bits Allocation</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/33_Mask_bits.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Indicating the Chosen Mask in QR Code</div>
			</div>

			<p>
			Once we've encoded our message, <b><code>HELLOWORLD</code></b>, and chosen our mask (in this case, mask number 3), we need to indicate within the QR code which mask was used. This is crucial for the scanner to decode the QR code correctly.
			</p>

			<p>
			To do this, we allocate the next three modules of additional information. With three modules, we can encode up to eight numbers, corresponding to the number of available masks. Each module is assigned a number based on a power of two. We then color the modules such that their combined value equals the mask number. For mask number 3, we color the modules corresponding to numbers 1 and 2.
			</p>
			</section>

			<section id="EC_and_Mask_for_Additional_Information">
			<h2>Error Correction and Mask for Additional Information</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/34_Additional_Info_EC.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Error Correction and Masking for Additional QR Code Data</div>
			</div>

			<p>
			Just as our main data needs error correction, so does our additional information.

			<p>
			For this purpose, we allocate the next ten modules for error correction, allowing us to correct up to five corrupted symbols. Using the BCH code, we calculate the ten error correction blocks and map them to the corresponding QR modules.</p>

			<p>This process can be intricate, so I reccomend using my program or following this detailed guide:
			</p>

			<blockquote class="stylish-quote">
			    <strong>Format and Version Information by Thonky:</strong> <br>
			    <a href="https://www.thonky.com/qr-code-tutorial/format-version-information">https://www.thonky.com/qr-code-tutorial/format-version-information</a>
			</blockquote>

			<p>
			Then, we apply a mask to the 15 bits of additional information. This process is similar to what we did for the main data, but the mask used for this step is always the same.
			</p>
			</section>

			<section id="Redundancy_in_Additional_Information">
			<h2>Redundancy in Additional Information</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/35_Additional_Info_redundancy.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Ensuring QR Code Reliability with Redundancy</div>
			</div>

			<p>
			To further enhance the reliability of our QR code, we copy the additional information into the two remaining corners. This redundancy ensures that even if the top-left corner is damaged or lost, the QR code remains readable.
			</p>

			<p class = "takeaway">
			Our code is ready.
			</p>
			</section>

			<section id="Importance_of_Additional_Information">
			<h2>Brute Force and the Importance of Additional Information</h2>

			<div class="video">
			    <video width="100%" controls>
			        <source src="qr_codes/36_Additional_Info_brute_force.mp4" type="video/mp4">
			        Your browser does not support the video tag.
			    </video>
			    <div>&nbsp;</div>
			    <div>Attempting to Decode QR without Additional Information</div>
			</div>

			<p>
			In theory, one could read a QR code without having the additional information intact. Each QR code could be generated using one of 4 levels of error correction and one of 8 masks. So, we can just try every possible combination of EC levels and masks. 4 times 8 equals 32 different combinations to try. 
			</p>

			<p>
			But it would take a human to read through all these results and pick out the one that makes sense. And in cases where the original message isn't a standard text message but some form of coded data, it could be nearly impossible to identify the correct result.
			</p>

			<p>
			That's why we take all necessary steps to protect and preserve this additional information in our QR codes.
			</p>
			</section>

			<section id="Additional_links">
			<h2>Additional links, acknowledgements, and attributions</h2>

			<ul>
				<li class="additional"><a href="https://zavier-henry.medium.com/an-introductory-walkthrough-for-encoding-qr-codes-5a33e1e882b5">
					"An Introductory Tutorial For Encoding QR Codes" by Zavier Henry
					</a>
				</li>

				<li class="additional"><a href="https://www.thonky.com/qr-code-tutorial/introduction">"QR Code Tutorial" by Thonky</a>
				</li>

				<li class="additional">
					<a href = "https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">"Reed-Solomon Error Correcting Codes from the Bottom Up" by tomverbeure</a>
				</li>

				<li class="additional">
					<a href = "https://sortofschool.org/tools/qr/qr">QR step-by-step generator tool</a>
					<ul>
						<li>
							<a href="https://github.com/sokolov-teach/qr">
								Github code
							</a>
						</li>
					</ul>
				</li>
			</ul>
			</section>

		</div>
	</div>
	<footer>
		<script src="../footer.js"></script>
	</footer>

</body>

</html>