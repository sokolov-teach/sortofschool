<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="/img/favicon.svg" type="image/svg+xml" sizes="any">
	<link rel="shortcut icon" type="image/png" href="/img/favicon.png">
	<link rel="shortcut icon" sizes="192x192" href="/img/favicon.png">
	<link rel="apple-touch-icon" href="/img/favicon.png">
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<title>Sort of School</title>
	<link href="../style.css" rel="stylesheet" />
	<script>
		MathJax = {
		    loader: {
		            load: ['input/tex-base', 'output/svg']
		        },
		    tex: {
		        tags: 'ams', // should be 'ams', 'none', or 'all'
		        tagSide: 'right',
		        inlineMath: [['$', '$'], ['\\(', '\\)']],
		        displayMath: [['\\[', '\\]']]
		    },
		    options: {
		        enableMenu: false
		    }
		};
	</script>
	<script>
		document.addEventListener("DOMContentLoaded", function() {
		    let toc = document.getElementById('toc');

		    // Extracted logic into a function for reusability
		    function checkTocPosition() {
		        if (toc.scrollTop === 0) {
		            toc.parentElement.classList.add('at-top');
		        } else {
		            toc.parentElement.classList.remove('at-top');
		        }

		        if (Math.ceil(toc.scrollTop) + toc.clientHeight >= toc.scrollHeight) {
		            toc.parentElement.classList.add('at-bottom');
		        } else {
		            toc.parentElement.classList.remove('at-bottom');
		        }
		    }

		    // Attach event listener for scroll
		    toc.addEventListener('scroll', checkTocPosition);

		    // Check the position initially
		    checkTocPosition();
		});
	</script>
	<script id="MathJax-script" async
	  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
	</script>
</head>


<body>
	<header>
		<script src="../header.js"></script>
		<a id="top"></a>
	</header>

	<figure>
		<img src="qr_codes/revelation.png" alt="test" />
		<figcaption aria-hidden="true">King James Bible (1611)</figcaption>
	</figure>

	<div class="content-container">

		<div class="toc-wrapper">
		    <div id="toc">
		    	<h2>Table of Contents</h2>
		    	<ul>
    <li><a href="#qr-first-version" id="toc-qr-first-version"><span
    class="toc-section-number">1</span> QR first version</a></li>
    <li><a href="#patterns" id="toc-patterns"><span
    class="toc-section-number">2</span> Patterns</a>
    <ul>
    <li><a href="#finder-patterns" id="toc-finder-patterns"><span
    class="toc-section-number">2.1</span> Finder patterns</a></li>
    <li><a href="#timing-patterns" id="toc-timing-patterns"><span
    class="toc-section-number">2.2</span> Timing Patterns</a></li>
    <li><a href="#additional-information"
    id="toc-additional-information"><span
    class="toc-section-number">2.3</span> Additional
    Information</a></li>
    </ul></li>
    <li><a href="#modes-of-encoding" id="toc-modes-of-encoding"><span
    class="toc-section-number">3</span> Modes of Encoding</a>
    <ul>
    <li><a href="#message-length" id="toc-message-length"><span
    class="toc-section-number">3.1</span> Message Length</a></li>
    <li><a href="#possible-combinations"
    id="toc-possible-combinations"><span
    class="toc-section-number">3.2</span> Possible Combinations</a></li>
    <li><a href="#byte-mode-encoding" id="toc-byte-mode-encoding"><span
    class="toc-section-number">3.3</span> Byte Mode Encoding</a></li>
    <li><a href="#numeric-mode" id="toc-numeric-mode"><span
    class="toc-section-number">3.4</span> Numeric Mode</a></li>
    <li><a href="#alphanumeric-mode" id="toc-alphanumeric-mode"><span
    class="toc-section-number">3.5</span> Alphanumeric Mode</a></li>
    <li><a href="#kanji-mode" id="toc-kanji-mode"><span
    class="toc-section-number">3.6</span> Kanji Mode</a></li>
    </ul></li>
    <li><a href="#error-correction" id="toc-error-correction"><span
    class="toc-section-number">4</span> Error Correction</a>
    <ul>
    <li><a href="#error-correction-level"
    id="toc-error-correction-level"><span
    class="toc-section-number">4.1</span> Error Correction
    Level</a></li>
    <li><a href="#error-correction-bits"
    id="toc-error-correction-bits"><span
    class="toc-section-number">4.2</span> Error Correction Bits</a></li>
    <li><a href="#pad-blocks" id="toc-pad-blocks"><span
    class="toc-section-number">4.3</span> Pad Blocks</a></li>
    <li><a href="#understanding-reed-solomon-error-correction"
    id="toc-understanding-reed-solomon-error-correction"><span
    class="toc-section-number">4.4</span> Understanding Reed-Solomon
    Error Correction</a></li>
    <li><a
    href="#reed-solomon-error-correction-verification-and-restoration"
    id="toc-reed-solomon-error-correction-verification-and-restoration"><span
    class="toc-section-number">4.5</span> Reed-Solomon Error Correction:
    Verification and Restoration</a></li>
    <li><a href="#galois-fields-in-qr-code-error-correction"
    id="toc-galois-fields-in-qr-code-error-correction"><span
    class="toc-section-number">4.6</span> Galois Fields in QR Code Error
    Correction</a></li>
    <li><a href="#error-correction-modules-placement-in-qr-code"
    id="toc-error-correction-modules-placement-in-qr-code"><span
    class="toc-section-number">4.7</span> Error Correction Modules
    Placement in QR Code</a></li>
    </ul></li>
    <li><a href="#masking" id="toc-masking"><span
    class="toc-section-number">5</span> Masking</a>
    <ul>
    <li><a href="#mask-problem" id="toc-mask-problem"><span
    class="toc-section-number">5.1</span> Mask Problem</a></li>
    <li><a href="#types-of-masks" id="toc-types-of-masks"><span
    class="toc-section-number">5.2</span> Types of Masks</a></li>
    <li><a href="#mask-application-process"
    id="toc-mask-application-process"><span
    class="toc-section-number">5.3</span> Mask Application
    Process</a></li>
    <li><a href="#mask-evaluation-process"
    id="toc-mask-evaluation-process"><span
    class="toc-section-number">5.4</span> Mask Evaluation
    Process</a></li>
    <li><a href="#mask-bits-allocation"
    id="toc-mask-bits-allocation"><span
    class="toc-section-number">5.5</span> Mask Bits Allocation</a></li>
    </ul></li>
    <li><a href="#error-correction-and-mask-for-additional-information"
    id="toc-error-correction-and-mask-for-additional-information"><span
    class="toc-section-number">6</span> Error Correction and Mask for
    Additional Information</a>
    <ul>
    <li><a href="#redundancy-in-additional-information"
    id="toc-redundancy-in-additional-information"><span
    class="toc-section-number">6.1</span> Redundancy in Additional
    Information</a></li>
    <li><a
    href="#brute-force-and-the-importance-of-additional-information"
    id="toc-brute-force-and-the-importance-of-additional-information"><span
    class="toc-section-number">6.2</span> Brute Force and the Importance
    of Additional Information</a></li>
    </ul></li>
    <li><a href="#additional-links-acknowledgements-and-attributions"
    id="toc-additional-links-acknowledgements-and-attributions"><span
    class="toc-section-number">7</span> Additional links,
    acknowledgements, and attributions</a></li>
    </ul>
		    </div>
	    </div>

		<div class="page">
			<h1>QR codes</h1>
			<style>
    table, th, td {
        font-size: 0.9em !important; /* Reset the font size to the browser's default for tables */
    }

    table {
      width: 80%;
      border-collapse: collapse;
      align-items: center;
      margin-left: auto;
      margin-right: auto;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    td:nth-child(odd){
      background-color: #f2f2f2;
    }

    tr:hover {
      background-color: #ddd;
    }
  </style>
<iframe src="https://www.youtube.com/embed/SZEHDjV07J0" title="YouTube video player" frameborder="0" controls="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
<section id="qr-first-version" class="level2" data-number="1">
<h2 data-number="1"><span class="header-section-number">1</span> QR
first version</h2>
<p><video src="qr_codes/1_QR_first_version.mp4" controls=""><a
href="qr_codes/1_QR_first_version.mp4">Video</a></video></p>
<p>The ISO 18004 Standard is like a guidebook for QR codes. It’s 126
pages long and tells us how QR codes are made.</p>
<p>I am creating the First Version of the QR code, it’s the simplest
one, and its matrix consists of 21 by 21 modules. The other versions are
bigger, so it’s harder to show them on a small screen.</p>
<p>There is also a Micro-QR version, which is really cool, but almost
none of the QR-code scanner apps could read them.</p>
</section>
<section id="patterns" class="level2" data-number="2">
<h2 data-number="2"><span class="header-section-number">2</span>
Patterns</h2>
<section id="finder-patterns" class="level3" data-number="2.1">
<h3 data-number="2.1"><span class="header-section-number">2.1</span>
Finder patterns</h3>
<p><video src="qr_codes/2_Finder_patterns.mp4" controls=""><a
href="qr_codes/2_Finder_patterns.mp4">Video</a></video></p>
<p>Now, the square doesn’t have any properties that would help
distinguish the top from the bottom and determine that it is a QR code
that we see and not a grid paper. So let there be <strong>finder
patterns</strong> in three corners. That way we can always orient the
QR-code the right way, no matter what angle it was shot from. The finder
patterns always occupy 8 by 8 modules in these corners.</p>
</section>
<section id="timing-patterns" class="level3" data-number="2.2">
<h3 data-number="2.2"><span class="header-section-number">2.2</span>
Timing Patterns</h3>
<p><video src="qr_codes/3_Timing_patterns.mp4" controls=""><a
href="qr_codes/3_Timing_patterns.mp4">Video</a></video></p>
<p>The next problem is that there are no grids on real QR codes. Without
them, it’s hard to tell where each module is. Therefore, to help the
scanner distinguish the columns and the rows from each other, we need
so-called <strong>timing patterns</strong>. These consist of lines of
alternating dark and light modules that connect the finder patterns,
plus one dark module situated close to the bottom-left finder pattern,
and they help to distinguish between rows and columns.</p>
</section>
<section id="additional-information" class="level3" data-number="2.3">
<h3 data-number="2.3"><span class="header-section-number">2.3</span>
Additional Information</h3>
<p><video src="qr_codes/4_Additional_info.mp4" controls=""><a
href="qr_codes/4_Additional_info.mp4">Video</a></video></p>
<p>Finally, strips of modules with a thickness of one are reserved by
now for <strong>additional information.</strong></p>
</section>
</section>
<section id="modes-of-encoding" class="level2" data-number="3">
<h2 data-number="3"><span class="header-section-number">3</span> Modes
of Encoding</h2>
<p><video src="qr_codes/5_Modes_of_encoding.mp4" controls=""><a
href="qr_codes/5_Modes_of_encoding.mp4">Video</a></video></p>
<p>All these elements, from search patterns to timing patterns, can be
found in any QR code. A message is written into the rest of the modules
by painting some of them black. But why use black cells instead of
letters?</p>
<p>There are actually 4 main alphabets or modes of encoding that can be
used:</p>
<ul>
<li>Numeric</li>
<li>Alphanumeric</li>
<li>Byte</li>
<li>Kanji</li>
</ul>
<p>So before writing our message, we need to specify the method of
encoding that we use. For this, the first four modules in the bottom
right corner of the QR code are assigned. By choosing one of the modes,
we are painting the corresponding module black.</p>
<p>Let’s start with the <strong>byte mode</strong> to understand the
basics. This alphabet contains 256 different symbols from a specified
character set (ISO/IEC 8859-1). Small and capital letters, numbers,
punctuation marks, and anything else you might need to write a
message.</p>
<details>
<summary>
<strong>See ISO/IEC 8859-1 table</strong>
</summary>
<br>
<table border="1">
<tbody id="characterTableBody">
</tbody>
</table>
</details>
<!-- ISO/IEC 8859-1 table script -->
<script>
document.addEventListener("DOMContentLoaded", function() {
    const tableBody = document.getElementById('characterTableBody');

    // Control character names
    const controlChars = [
        "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
        "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI",
        "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
        "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"
    ];

    for(let row = 0; row < 32; row++) {
        const tableRow = document.createElement('tr');

        // For 8 character slots per row
        for(let col = 0; col < 8; col++) {
            const decimalValue = col * 32 + row;

            // Add decimal cell
            const decimalCell = document.createElement('td');
            decimalCell.textContent = decimalValue;
            tableRow.appendChild(decimalCell);

            // Add character or control character name
            const charCell = document.createElement('td');
            if (decimalValue < 32) {
                charCell.textContent = controlChars[decimalValue];
            } else if (decimalValue >= 128 && decimalValue <= 159) {
                charCell.innerHTML = "&nbsp;"; // HTML non-breaking space
            } else if (decimalValue <= 255) {
                charCell.textContent = String.fromCharCode(decimalValue);
            }
            tableRow.appendChild(charCell);
        }

        tableBody.appendChild(tableRow);
    }
});

</script>
<section id="message-length" class="level3" data-number="3.1">
<h3 data-number="3.1"><span class="header-section-number">3.1</span>
Message Length</h3>
<p><video src="qr_codes/6_Message_length.mp4" controls=""><a
href="qr_codes/6_Message_length.mp4">Video</a></video></p>
<p>Let’s see how we can represent some information using it. For
example, the 10-letter string <strong><code>HELLOWORLD</code></strong>.
The next 8 modules in the QR-code are allocated to represent the length
of our message. Each module is assigned a number equal to a power of two
in a specific order. The next step is to paint the corresponding
modules, so their sum is equal to the length of the message, in our
case, it is 8 and a 2.</p>
</section>
<section id="possible-combinations" class="level3" data-number="3.2">
<h3 data-number="3.2"><span class="header-section-number">3.2</span>
Possible Combinations</h3>
<p><video src="qr_codes/7_Possible_combinations.mp4" controls=""><a
href="qr_codes/7_Possible_combinations.mp4">Video</a></video></p>
<p>Now we are ready to encode characters themselves. How can we use
modules to do that?</p>
<ul>
<li>1 module: 2 combinations (black or white) which can represent
numbers 0 and 1 or letters A and B.</li>
<li>2 modules: We get 4 combinations, representing numbers 0 to 3 or
letters A to D.</li>
<li>3 modules: This gives 8 combinations.</li>
<li>4 modules: We have 16 combinations, which can represent numbers 0 to
15 or letters A to P.</li>
</ul>
<p>Moreover, if the number of modules that are used to encode one
character equals <span class="math inline">\(N\)</span>, the number of
possible characters equals <span class="math inline">\(2^N\)</span>.</p>
<p><span class="math display">\[ \text{possible combinations} = 2^N
\]</span></p>
</section>
<section id="byte-mode-encoding" class="level3" data-number="3.3">
<h3 data-number="3.3"><span class="header-section-number">3.3</span>
Byte Mode Encoding</h3>
<p><img src="qr_codes/8_Byte_mode_block.png" /></p>
<p>To simplify the process of creating a block that corresponds to some
number, we assign to each module in a block a number that is equal to a
power of two. The sum of the numbers in the modules that are painted
black equals the number that the block represents.</p>
<blockquote>
<p><strong>Why Powers of Two?</strong> The choice of powers of two is
rooted in binary representation, the fundamental language of computers.
In binary, everything is represented using only two numbers: 0 and 1.
This system is efficient and universal for digital encoding.</p>
</blockquote>
<p>In byte-mode, we have 256 possible characters that we can use in our
message. So, to be able to represent any character from this sheet, we
need 8 modules in a block.</p>
<p>For example: - If only the modules representing the numbers 64 and 1
are colored black, this block represents the 65th character, which is
‘A’. - If all the modules in a block are colored black, it represents
the last character in the set — some strange French umlaut ‘ÿ’.</p>
<section id="letter-placement-and-encoding" class="level4"
data-number="3.3.1">
<h4 data-number="3.3.1"><span class="header-section-number">3.3.1</span>
Letter Placement and Encoding</h4>
<p><video src="qr_codes/9_Letters_placement.mp4" controls=""><a
href="qr_codes/9_Letters_placement.mp4">Video</a></video></p>
<p>That’s why for every character in our message, we are allocating a
block of 8 modules in this specific order. Then, we change each
character to its corresponding number on the character sheet. This
number then tells us which modules to color black in our 8-module
block.</p>
</section>
<section id="zigzag-order-and-module-assignment" class="level4"
data-number="3.3.2">
<h4 data-number="3.3.2"><span class="header-section-number">3.3.2</span>
Zigzag Order and Module Assignment</h4>
<p><video src="qr_codes/10_Zigzag_order.mp4" controls=""><a
href="qr_codes/10_Zigzag_order.mp4">Video</a></video></p>
<p>Each module within a block is assigned a value based on powers of
two, but this assignment follows a specific zig-zag order. Once these
values are assigned, the next step involves painting the modules. The
modules are painted such that their combined value matches the number
representing a specific character.</p>
</section>
<section id="encoding-letters-in-qr-codes" class="level4"
data-number="3.3.3">
<h4 data-number="3.3.3"><span class="header-section-number">3.3.3</span>
Encoding Letters in QR Codes</h4>
<p><video src="qr_codes/11_Encoding_letters.mp4" controls=""><a
href="qr_codes/11_Encoding_letters.mp4">Video</a></video></p>
<p>Let’s take the letter <strong>H</strong> as an example:</p>
<p>The letter <strong>H</strong> might be the seventy-second character
in the list. To represent the number 72, we break it down into its power
of two components: 64 and 8. Thus, in the block representing
<strong>H</strong>, the modules corresponding to the values 64 and 8 are
painted black.</p>
<p><span class="math display">\[ (H) 72 = 64 + 8 \]</span></p>
<p>This method ensures that each character in the message is uniquely
represented by a combination of black and white modules in its
corresponding block. Once we’ve encoded our entire message, we need a
way to show that the message is complete. This is done using a
<strong>terminator</strong>, which is simply four white modules in a
row.</p>
</section>
<section id="why-not-always-use-byte-mode" class="level4"
data-number="3.3.4">
<h4 data-number="3.3.4"><span class="header-section-number">3.3.4</span>
Why Not Always Use Byte Mode?</h4>
<p><img src="qr_codes/12_Byte_mode_max_length.png" /></p>
<p>You might wonder, with byte mode’s ability to represent so many
characters, why bother with other modes? While byte mode does offer a
wide range of characters, it has a limitation. Using byte mode, we can
only encode a message up to 17 characters long. We also can’t use all
the modules, as some are reserved for error correction later on.</p>
<p><strong>Numeric</strong> and <strong>Alphanumeric</strong> modes
offer a more efficient way to encode messages. They use clever encoding
methods that let us fit more characters into the same QR code size
without making it bigger. This means we can convey longer messages
without needing a larger QR code.</p>
</section>
</section>
<section id="numeric-mode" class="level3" data-number="3.4">
<h3 data-number="3.4"><span class="header-section-number">3.4</span>
Numeric Mode</h3>
<p><video src="qr_codes/13_Numeric_mode.mp4" controls=""><a
href="qr_codes/13_Numeric_mode.mp4">Video</a></video></p>
<p>Numeric mode is designed specifically for encoding numbers. It’s
perfect for things like prices, phone numbers, book indexes, or tracking
inventory items. In this mode, only the digits 0 through 9 are used.</p>
<p>If we follow the logic we’ve learned, encoding 10 different symbols
(the numbers 0-9) would require at least 4 modules. Why? Because 3
modules can only represent 8 different combinations <span
class="math inline">\(2^3 = 8\)</span>, which isn’t enough for 10
numbers.</p>
<p><span class="math inline">\(2^4=16\)</span> which is greater than 10.
So, 4 modules can represent all 10 numbers with some combinations to
spare.</p>
<p>When we divide our modules into blocks of four, we can fit 34 digits
using Numeric mode.</p>
<section id="numeric-vs.-byte-mode" class="level4" data-number="3.4.1">
<h4 data-number="3.4.1"><span class="header-section-number">3.4.1</span>
Numeric vs. Byte Mode</h4>
<p><img src="qr_codes/14_Numeric_Byte_length_comparation.png" /></p>
<p>Numeric mode has a greater capacity than if we were using the
256-character alphabet of byte mode. The key takeaway here is
simple:</p>
<p class="takeaway">
The fewer characters in our chosen alphabet, the more information we can
pack into the same QR code space.
</p>
</section>
<section id="numeric-mode-4bit" class="level4" data-number="3.4.2">
<h4 data-number="3.4.2"><span class="header-section-number">3.4.2</span>
Numeric Mode 4bit</h4>
<p><video src="qr_codes/15_Numeric_4bit.mp4" controls=""><a
href="qr_codes/15_Numeric_4bit.mp4">Video</a></video></p>
<p>But this approach is not very effective. By choosing to use only 10
out of all 16 combinations, we actually use only 62.5% of the available
space!</p>
<p><span class="math display">\[ \frac{2^4}{10} = \frac{10}{16} = 62.5\%
\]</span></p>
</section>
<section id="numeric-mode-10bit" class="level4" data-number="3.4.3">
<h4 data-number="3.4.3"><span class="header-section-number">3.4.3</span>
Numeric Mode 10bit</h4>
<p><video src="qr_codes/16_Numeric_10bit.mp4" controls=""><a
href="qr_codes/16_Numeric_10bit.mp4">Video</a></video></p>
<p>To make better use of the available space, numeric mode actually sets
aside 10 modules for encoding, not just 4. This allows for:</p>
<p><span class="math display">\[ 2^{10} = 1024 \]</span></p>
<p>possible characters or combinations.</p>
<p>Consider encoding a date:</p>
<p><span class="math display">\[18082023\]</span></p>
<p>Before encoding, we can split the date into groups of three
digits:</p>
<p><span class="math display">\[180/ 820/ 23\]</span></p>
<p>Each group is then encoded as a 10-bit number. Given that there are
only 1000 possible numbers ranging from 0 to 999, this method achieves
nearly 98% utilization of the available space.</p>
<p><span class="math display">\[ \frac{1000}{2^{10}} = \frac{1000}{1024}
\approx 98\% \]</span></p>
<p>Think of this encoding method as translating our message into a
unique language. In this language, the alphabet consists of 1000
characters. By using this approach, we’re making the most out of the
space provided by the QR code, ensuring efficient and compact
encoding.</p>
</section>
<section id="bit-vs-10-bit-numeric-encoding-efficiency" class="level4"
data-number="3.4.4">
<h4 data-number="3.4.4"><span class="header-section-number">3.4.4</span>
4-bit vs 10-bit Numeric Encoding Efficiency</h4>
<p><img src="qr_codes/17_4bit_10bit_length_comparation.png" /></p>
<p>By using the encoding method where we group three digits together and
represent each group with 10 modules, we can achieve impressive
efficiency. This method allows us to encode a message that’s 41
characters long, provided the message is made up entirely of digits.</p>
</section>
</section>
<section id="alphanumeric-mode" class="level3" data-number="3.5">
<h3 data-number="3.5"><span class="header-section-number">3.5</span>
Alphanumeric Mode</h3>
<p><video src="qr_codes/18_Alphanumeric_mode.mp4" controls=""><a
href="qr_codes/18_Alphanumeric_mode.mp4">Video</a></video></p>
<p>The <strong>alphanumeric mode</strong> allows to encode the above
digits, A to Z upper-characters, and some symbols, which makes it the
best option for encoding the links to web-sites.</p>
<section id="alphanumeric-efficiency-with-6-bit-encoding" class="level4"
data-number="3.5.1">
<h4 data-number="3.5.1"><span class="header-section-number">3.5.1</span>
Alphanumeric Efficiency with 6-bit Encoding</h4>
<p><img src="qr_codes/19_Alphanumeric_wasteful.png" /></p>
<p>With 45 symbols in the alphanumeric set, direct encoding (one symbol
at a time) would need at least 6 modules. However, this method would
only use about 70% of the available space.</p>
</section>
<section id="alphanumeric-efficiency-with-11-bit-encoding"
class="level4" data-number="3.5.2">
<h4 data-number="3.5.2"><span class="header-section-number">3.5.2</span>
Alphanumeric Efficiency with 11-bit Encoding</h4>
<p><video src="qr_codes/20_Alphanumeric_11bit.mp4" controls=""><a
href="qr_codes/20_Alphanumeric_11bit.mp4">Video</a></video></p>
<p>To improve efficiency, a similar approach to the one used in numeric
mode is employed. Instead of encoding each character individually, the
string is divided into pairs of characters. Essentially, every
two-symbol combination becomes a new, unique character.</p>
<p>How many unique pairs can be formed? By pairing each symbol with
every other symbol (including itself), we create a 45 by 45 grid of
combinations. This results in:</p>
<p><span class="math display">\[45^2 = 2025\]</span></p>
<p>unique pairs. To represent all 2025 combinations, we’d need
combinations from 11 modules, which can represent:</p>
<p><span class="math display">\[2^{11} = 2048\]</span></p>
<p>combinations. This method achieves an impressive utilization of
nearly 99%!</p>
<p><span class="math display">\[\frac{2025}{2048} ≈ 98.8\%\]</span></p>
</section>
</section>
<section id="kanji-mode" class="level3" data-number="3.6">
<h3 data-number="3.6"><span class="header-section-number">3.6</span>
Kanji Mode</h3>
<p><img src="qr_codes/21_Kanji.png" /></p>
<p>The Kanji mode is designed to encode the vast array of characters in
the Kanji alphabet, which consists of 6090 characters. To represent each
character, 13 modules are allocated. This results in a utilization of
about 75%. Given the size constraints of our QR code, only 10 Kanji
characters can fit. No tricks are used here to achieve better
utilization.</p>
</section>
</section>
<section id="error-correction" class="level2" data-number="4">
<h2 data-number="4"><span class="header-section-number">4</span> Error
Correction</h2>
<section id="error-correction-level" class="level3" data-number="4.1">
<h3 data-number="4.1"><span class="header-section-number">4.1</span>
Error Correction Level</h3>
<p><video src="qr_codes/22_Error_correction_level.mp4" controls=""><a
href="qr_codes/22_Error_correction_level.mp4">Video</a></video></p>
<p>One remarkable feature of QR codes is their robustness. Whether
they’re partially obscured, damaged, or even if a logo covers part of
the code, they remain readable. This resilience is largely due to error
correction.</p>
<p>Let’s explore error correction using the byte mode, as it’s visually
simpler.</p>
<p>There are four levels of error correction, each requiring a different
amount of space in the QR code. The higher the error correction level,
the more robust the QR code is against damage, but the less space
remains for the actual message. For our QR code size, we can encode:</p>
<ul>
<li>7 characters at High level</li>
<li>11 characters at Quartile level</li>
<li>14 characters at Medium level</li>
<li>17 characters at Low level</li>
</ul>
</section>
<section id="error-correction-bits" class="level3" data-number="4.2">
<h3 data-number="4.2"><span class="header-section-number">4.2</span>
Error Correction Bits</h3>
<p><video src="qr_codes/23_Error_correction_bits.mp4" controls=""><a
href="qr_codes/23_Error_correction_bits.mp4">Video</a></video></p>
<p>To indicate the chosen error correction level, only 2 modules are
needed, as there are just four levels. They are placed in additional
information.</p>
</section>
<section id="pad-blocks" class="level3" data-number="4.3">
<h3 data-number="4.3"><span class="header-section-number">4.3</span> Pad
Blocks</h3>
<p><video src="qr_codes/24_Pad_blocks.mp4" controls=""><a
href="qr_codes/24_Pad_blocks.mp4">Video</a></video></p>
<p>Let’s get back to our message “HELLOWORLD” and we’ll use the Low
level of error correction, which allows for a message up to 17
characters long. The remaining space, enough for 7 characters, is
reserved for error correction.</p>
<p>However, our message is only 10 characters long. To utilize the
unused space, two alternating characters from the character sheet are
used, specifically characters numbered 236 and 17. These characters
likely create a contrasting pattern, ensuring they aren’t mistaken for
actual data.</p>
<p>The 7 blocks of 8 modules allocated for these padding characters are
encoded similarly to our main message. Any timing pattern in the way is
skipped. Each module in a block is given a value based on powers of two,
and the necessary modules are colored to represent the character.</p>
<p>With our message encoded, all that remains is to fill in the error
correction blocks, ensuring our QR code is both informative and
resilient.</p>
</section>
<section id="understanding-reed-solomon-error-correction" class="level3"
data-number="4.4">
<h3 data-number="4.4"><span class="header-section-number">4.4</span>
Understanding Reed-Solomon Error Correction</h3>
<p><video src="qr_codes/25_Reed_Solomon.mp4" controls=""><a
href="qr_codes/25_Reed_Solomon.mp4">Video</a></video></p>
<p>The Systematic Reed-Solomon Error correction in Galois Fields is a
daunting task. Let’s start with just Reed-Solomon and look at Galois
Fields later.</p>
<p>Due to difficulty of calculations, we’ll take a shorter message, for
example <strong>GOD</strong>. Using the byte-mode alphabet, the
characters G, O, and D are assigned the numbers 71, 79, and 68,
respectively. Our goal is to create codewords – error correction numbers
that can help restore the original numbers if they get corrupted. The
Reed-Solomon error correction is designed such that only half the number
of codewords can be recovered. For instance, to recover 1 corrupted
symbol, 2 codewords are needed.</p>
<p>The generator polynomial is created with known roots, equal to the
number of codewords. For our example, the roots are 1 and 2, resulting
in the polynomial:</p>
<p><span class="math display">\[ g(x) = x^2 - 3x + 2 \]</span></p>
<p>This polynomial equals zero when <span
class="math inline">\(x\)</span> is 1 or 2.</p>
<p><span class="math display">\[
\begin{cases}
g(1) = 0 \\
g(2) = 0
\end{cases}
\]</span></p>
<p>The message polynomial is derived from the original message numbers
and is multiplied by <span class="math inline">\(x\)</span> raised to
the power of the number of codewords:</p>
<p><span class="math display">\[ m(x) = (71x^2 + 79x + 68) x^2 = 71x^4 +
79x^3 + 68x^2 \]</span></p>
<p>To obtain the codewords, polynomial division is performed between the
message polynomial and the generator polynomial. The result is a
quotient and a remainder. The difference between the message polynomial
and the remainder polynomial equals the quotient multiplied by the
generator polynomial. The remainder serves as the codewords.</p>
<p>For our example, the remainder polynomial is:</p>
<p><span class="math display">\[ r(x) = 1822x - 1604 \]</span></p>
<p>And the polynomial to be transmitted:</p>
<p><span class="math display">\[ s(x) = m(x) - r(x) = 71x^4 + 79x^3 +
68x^2 - 1822x + 1604 \]</span></p>
</section>
<section id="reed-solomon-error-correction-verification-and-restoration"
class="level3" data-number="4.5">
<h3 data-number="4.5"><span class="header-section-number">4.5</span>
Reed-Solomon Error Correction: Verification and Restoration</h3>
<p><video src="qr_codes/26_Reed_Solomon_correction.mp4" controls=""><a
href="qr_codes/26_Reed_Solomon_correction.mp4">Video</a></video></p>
<p>When we receive a QR code message, we can verify its integrity by
substituting values into the polynomial. For instance, using values 1
and 2:</p>
<p><span class="math display">\[ s(x) = 71x^4 + 79x^3 + 68x^2 - 1822x +
1604 \]</span></p>
<p><span class="math display">\[
\begin{cases}
s(1) = 0 \\
s(2) = 0
\end{cases}
\]</span></p>
<p>If the result is zero, it indicates that the message has not been
corrupted.</p>
<p>However, let’s imagine a scenario where the first coefficient is
tampered with, changing it to 77. This would alter the message,
potentially changing its meaning:</p>
<p><span class="math display">\[ [77, 79, 68, -1822, 1604] \]</span></p>
<p>To detect and correct this error, we can employ a method that
involves replacing the suspected incorrect coefficient with a variable,
say <span class="math inline">\(P\)</span>:</p>
<p><span class="math display">\[ s(x) = Px^4 + 79x^3 + 68x^2 - 1822x +
1604 \]</span></p>
<p>Given that this polynomial should equate to zero when <span
class="math inline">\(x\)</span> is either 1 or 2, we can substitute
these values in:</p>
<p><span class="math display">\[
\begin{cases}
s(1) = P + 79 + 68 - 1822 + 1604 = 0 \\
s(2) = 16P + 632 + 272 - 3644 + 1604 = 0
\end{cases}
\]</span></p>
<p>Solving these equations, we find that in both cases, <span
class="math inline">\(P\)</span> equals 71.</p>
<p><span class="math display">\[
\begin{cases}
P = 71 \\
P = 71
\end{cases}
\]</span></p>
<p>This confirms that the original coefficient was 71, and the message
has been restored. If the results were different, we would continue this
process with the next coefficient until the corrupted one is
identified.</p>
<blockquote>
<p><strong>Additional Links on Reed-Solomon:</strong></p>
<ul>
<li><a
href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">Reed-Solomon
Error Correcting Codes from the Bottom Up by tomverbeure</a></li>
<li><a href="https://www.youtube.com/watch?v=1pQJkt7-R4Q">What are
Reed-Solomon Codes by vcubingx</a></li>
</ul>
</blockquote>
</section>
<section id="galois-fields-in-qr-code-error-correction" class="level3"
data-number="4.6">
<h3 data-number="4.6"><span class="header-section-number">4.6</span>
Galois Fields in QR Code Error Correction</h3>
<p><video src="qr_codes/27_Galois_field.mp4" controls=""><a
href="qr_codes/27_Galois_field.mp4">Video</a></video></p>
<p>While the Reed-Solomon error correction method seems promising,
applying it directly to QR codes presents challenges. With 8 modules per
block, the highest number we can encode is 255. However, our codewords
are in the thousands, and some are even negative. This is where
<strong>Galois fields</strong> come into the picture.</p>
<p>In Galois fields, we don’t rely on traditional arithmetic. Instead,
we work with numbers up to 255. Addition and subtraction are performed
using XOR (exclusive or), while multiplication and division are rooted
in logarithmic and exponential tables (there are also other methods that
can be used). Despite these unconventional rules, the essence of
codeword generation, error detection, and correction remains the same.
This method ensures all numbers stay within the 0-255 range, making them
encodable in 8-bit blocks.</p>
<p>Attempting these calculations by hand, even for a short word, is a
daunting task. For our <strong>HELLOWORLD</strong> message, which has 10
letters and requires 7 codewords, manual calculations are impractical.
The challenge lies in our unfamiliarity with this unique arithmetic. For
those intrigued, there’s an article detailing the arithmetic rules of
the Galois field and a 16-step solution for a basic message.</p>
<blockquote>
<p><strong>Error Correction Coding in Galois fields by
Thonky:</strong></p>
<p><a
href="https://www.thonky.com/qr-code-tutorial/error-correction-coding">https://www.thonky.com/qr-code-tutorial/error-correction-coding</a></p>
</blockquote>
<p>If you want to skip this step, you can do it with a program that I’ve
developed for step-by-step QR code generation, available on my website
as an open-source tool.</p>
<blockquote>
<p><strong>QR Code step-by-step Generation Tool:</strong></p>
<p><a
href="https://sortofschool.org/tools/qr/qr">https://sortofschool.org/tools/qr/qr</a></p>
</blockquote>
</section>
<section id="error-correction-modules-placement-in-qr-code"
class="level3" data-number="4.7">
<h3 data-number="4.7"><span class="header-section-number">4.7</span>
Error Correction Modules Placement in QR Code</h3>
<p><video src="qr_codes/28_EC_module_placement.mp4" controls=""><a
href="qr_codes/28_EC_module_placement.mp4">Video</a></video></p>
<p>Using the above methods, we’re able to determine the 7 error
correction blocks required for encoding the message
<strong>HELLOWORLD</strong>. Once obtained, a power-of-two number is
assigned to each of these blocks. They are then strategically placed in
a distinct zig-zag pattern within the QR code.</p>
<p>The modules are then colored in, ensuring that the sum of the colored
modules aligns with the error correction number. With this step
complete, we’ve successfully finished the Error Correction component of
the QR code.</p>
</section>
</section>
<section id="masking" class="level2" data-number="5">
<h2 data-number="5"><span class="header-section-number">5</span>
Masking</h2>
<section id="mask-problem" class="level3" data-number="5.1">
<h3 data-number="5.1"><span class="header-section-number">5.1</span>
Mask Problem</h3>
<figure>
<img src="qr_codes/29_Mask_problem.png"
alt="Mask Problem in QR Codes" />
<figcaption aria-hidden="true">Mask Problem in QR Codes</figcaption>
</figure>
<p>While our QR code might seem ready, there’s a significant challenge
we haven’t addressed: the issue of uniformity. Large clusters of white
or black modules can make individual cells difficult to distinguish. To
illustrate this, consider encoding a message made up of the last 17
characters of the byte-mode alphabet, the strange French umlauts:</p>
<center>
<strong>ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ</strong>
</center>
<p>Such a message would result in a QR code with large, uniform areas,
making it hard to scan.</p>
<p>That’s where masks come into play. Masks are patterns applied to the
data portion of the code to break up large areas of uniform color. This
makes the QR code easier to scan and read.</p>
<p>When a QR code has extensive areas that are either unpainted or
entirely black, it becomes challenging for scanners to differentiate
between individual modules. Masks help by introducing variability into
the design, ensuring that no large uniform areas exist. This variability
aids in the accurate scanning of the QR code.</p>
</section>
<section id="types-of-masks" class="level3" data-number="5.2">
<h3 data-number="5.2"><span class="header-section-number">5.2</span>
Types of Masks</h3>
<p><img src="qr_codes/30_Mask_types.png" /></p>
<p>There are eight standard masks used in QR code generation. Each mask
has a unique pattern, and the best one is chosen based on specific
criteria, such as which results in the least number of uniform areas.
The selected mask is then applied to the QR code, ensuring a more varied
and scannable design.</p>
</section>
<section id="mask-application-process" class="level3" data-number="5.3">
<h3 data-number="5.3"><span class="header-section-number">5.3</span>
Mask Application Process</h3>
<p><video src="qr_codes/31_Mask_application.mp4" controls=""><a
href="qr_codes/31_Mask_application.mp4">Video</a></video></p>
<p>The process of masking involves XORing (“exclusive or” operation) the
chosen mask with the data and error correction blocks of the QR code.
Here’s a visual breakdown:</p>
<ol type="1">
<li>Overlap the QR code with the selected mask.</li>
<li>Modules that are bright or dark remain white.</li>
<li>Gray modules turn black.</li>
</ol>
<p>It’s essential to note that this operation is exclusive to data and
error correction modules. Finder patterns, timing patterns, and
additional information remain unchanged by the mask.</p>
<p>When it comes to decoding a masked QR code, the process is
straightforward. By performing the same XOR operation with the mask, the
QR code reverts to its original state, making it readable.</p>
</section>
<section id="mask-evaluation-process" class="level3" data-number="5.4">
<h3 data-number="5.4"><span class="header-section-number">5.4</span>
Mask Evaluation Process</h3>
<p><video src="qr_codes/32_Mask_evaluation.mp4" controls=""><a
href="qr_codes/32_Mask_evaluation.mp4">Video</a></video></p>
<p>While you can manually select any of the eight masks using my
program, real-world algorithms take a more sophisticated approach. They
generate all eight masks simultaneously and then evaluate which one is
the most suitable for the given QR code. This evaluation is based on a
“beauty contest” of sorts, where each mask is scored based on its
effectiveness.</p>
<p>The most “attractive” mask is the one with the lowest penalty score.
These scores are derived from four main rules:</p>
<ul>
<li><strong>Sequences:</strong> Avoid long vertical or horizontal
sequences of modules with the same color.</li>
<li><strong>Large Areas:</strong> Minimize extensive areas that have the
same color.</li>
<li><strong>Finder Pattern Resemblance:</strong> Evade patterns that
look like the finder pattern.</li>
<li><strong>Balance:</strong> Aim for an overall balance between dark
and light modules.</li>
</ul>
<p>After evaluating each mask based on these rules, the one with the
lowest penalty score is chosen and applied to the QR code.</p>
</section>
<section id="mask-bits-allocation" class="level3" data-number="5.5">
<h3 data-number="5.5"><span class="header-section-number">5.5</span>
Mask Bits Allocation</h3>
<p><video src="qr_codes/33_Mask_bits.mp4" controls=""><a
href="qr_codes/33_Mask_bits.mp4">Video</a></video></p>
<p>Once we’ve encoded our message, <strong>HELLOWORLD</strong>, and
chosen our mask (in this case, mask number 3), we need to indicate
within the QR code which mask was used. This is crucial for the scanner
to decode the QR code correctly.</p>
<p>To do this, we allocate the next three modules of additional
information. With three modules, we can encode up to eight numbers,
corresponding to the number of available masks. Each module is assigned
a number based on a power of two. We then color the modules such that
their combined value equals the mask number. For mask number 3, we color
the modules corresponding to numbers 1 and 2.</p>
</section>
</section>
<section id="error-correction-and-mask-for-additional-information"
class="level2" data-number="6">
<h2 data-number="6"><span class="header-section-number">6</span> Error
Correction and Mask for Additional Information</h2>
<p><video src="qr_codes/34_Additional_Info_EC.mp4" controls=""><a
href="qr_codes/34_Additional_Info_EC.mp4">Video</a></video></p>
<p>Just as our main data needs error correction, so does our additional
information.</p>
<p>For this purpose, we allocate the next ten modules for error
correction, allowing us to correct up to five corrupted symbols. Using
the BCH code, we calculate the ten error correction blocks and map them
to the corresponding QR modules.</p>
<div class="note">
<p>This process can be intricate, so I recommend using my program or
following this detailed guide:<br />
- <a
href="https://www.thonky.com/qr-code-tutorial/format-version-information"><strong>Format
and Version Information by Thonky</strong></a></p>
</div>
<p>Then, we apply a mask to the 15 bits of additional information. This
process is similar to what we did for the main data, but the mask used
for this step is always the same.</p>
<section id="redundancy-in-additional-information" class="level3"
data-number="6.1">
<h3 data-number="6.1"><span class="header-section-number">6.1</span>
Redundancy in Additional Information</h3>
<p><video src="qr_codes/35_Additional_Info_redundancy.mp4"
controls=""><a
href="qr_codes/35_Additional_Info_redundancy.mp4">Video</a></video></p>
<p>To further enhance the reliability of our QR code, we copy the
additional information into the two remaining corners. This redundancy
ensures that even if the top-left corner is damaged or lost, the QR code
remains readable.</p>
<div class="takeaway">
<strong>Our code is ready.</strong>
<div>

</section>
<section id="brute-force-and-the-importance-of-additional-information"
class="level3" data-number="6.2">
<h3 data-number="6.2"><span class="header-section-number">6.2</span>
Brute Force and the Importance of Additional Information</h3>
<p><video src="qr_codes/36_Additional_Info_brute_force.mp4"
controls=""><a
href="qr_codes/36_Additional_Info_brute_force.mp4">Video</a></video></p>
<p>In theory, one could read a QR code without having the additional
information intact. Each QR code could be generated using one of 4
levels of error correction and one of 8 masks. So, we can just try every
possible combination of EC levels and masks. 4 times 8 equals 32
different combinations to try.</p>
<p>But it would take a human to read through all these results and pick
out the one that makes sense. And in cases where the original message
isn’t a standard text message but some form of coded data, it could be
nearly impossible to identify the correct result.</p>
<p>That’s why we take all necessary steps to protect and preserve this
additional information in our QR codes.</p>
</section>
</section>
<section id="additional-links-acknowledgements-and-attributions"
class="level2" data-number="7">
<h2 data-number="7"><span class="header-section-number">7</span>
Additional links, acknowledgements, and attributions</h2>
<ul>
<li><a
href="https://zavier-henry.medium.com/an-introductory-walkthrough-for-encoding-qr-codes-5a33e1e882b5">“An
Introductory Tutorial For Encoding QR Codes” by Zavier Henry</a></li>
<li><a href="https://www.thonky.com/qr-code-tutorial/introduction">“QR
Code Tutorial” by Thonky</a></li>
<li><a
href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">“Reed-Solomon
Error Correcting Codes from the Bottom Up” by tomverbeure</a></li>
<li><a href="https://sortofschool.org/tools/qr/qr">QR step-by-step
generator tool</a>
<ul>
<li><a href="https://github.com/sokolov-teach/qr">Github code</a></li>
</ul></li>
</ul>
</section>
		</div>
	</div>
	<footer>
		<script src="../footer.js"></script>
	</footer>
</body>

</html>